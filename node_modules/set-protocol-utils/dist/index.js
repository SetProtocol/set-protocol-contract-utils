"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var web3_1 = __importDefault(require("web3"));
var constants_1 = require("./constants");
var bignumber_1 = require("./bignumber");
exports.BigNumber = bignumber_1.BigNumber;
var encoding_1 = require("./encoding");
var logs_1 = require("./logs");
var orders_1 = require("./orders");
var oracle_1 = require("./oracle");
var rebalancing_1 = require("./rebalancing");
var signing_1 = require("./signing");
var kyber_1 = require("./kyber");
var zeroEx_1 = require("./zeroEx");
var typeGuards_1 = require("./typeGuards");
var Web3Utils_1 = require("./Web3Utils");
exports.Web3Utils = Web3Utils_1.Web3Utils;
var bn_1 = require("./bn");
exports.BN = bn_1.BN;
var baseContract_1 = require("./baseContract");
exports.BaseContract = baseContract_1.BaseContract;
var types_1 = require("./types");
exports.SolidityTypes = types_1.SolidityTypes;
/**
 * The Utils class is an entry-point into the set-protocols-util.js library for reusable utility
 * methods that pertain to encoding, order generation, signing, etc.
 */
var SetProtocolUtils = /** @class */ (function () {
    /**
     * Initialize a Utils class
     *
     * @param web3   Web3 instance to use
     */
    function SetProtocolUtils(web3) {
        this.web3 = web3 || new web3_1.default(new web3_1.default.providers.HttpProvider('http://localhost:8545'));
    }
    /* ============ Static SetProtocolUtils Functions ============ */
    /**
     * Generates a pseudo-random 256-bit salt
     *
     * @return  A pseudo-random 256-bit number that can be used as a salt
     */
    SetProtocolUtils.generateSalt = function () {
        return orders_1.generateSalt();
    };
    /**
     * Function for clarifying the additional call data parameters that need to be sent to Core when creating
     * a new rebalancing set token
     *
     * @param  managerAddress      Address of the manager to manage the rebalancing
     * @param  proposalPeriod      Time the participants of the Set can withdraw from a rebalance
     *                               once a new Set has been proposed
     * @param  rebalanceInterval   Time between when the manager can initiate another rebalance
     * @return                     String representing call data to send to Core contracts
     */
    SetProtocolUtils.generateRebalancingSetTokenCallData = function (managerAddress, proposalPeriod, rebalanceInterval) {
        return rebalancing_1.generateRebalancingSetTokenCallData(managerAddress, proposalPeriod, rebalanceInterval);
    };
    /**
     * Function for clarifying the additional call data parameters that need to be sent to Core when creating
     * a new rebalancing set token
     *
     * @param  managerAddress           Address of the manager to manage the rebalancing
     * @param  liquidatorAddress        Address of the contract that handles trade execution
     * @param  recipientAddress         Address of recipient of fees
     * @param  rebalanceInterval        Time between when the manager can initiate another rebalance
     * @param  lastRebalanceTimestamp   Customized time in seconds of the last rebalance
     * @param  entryFee                 Mint fee in scaled value (10e18 value)
     * @param  rebalanceFee             Rebalance fee in scaled value
     * @return                     String representing call data to send to Core contracts
     */
    SetProtocolUtils.generateRebalancingSetTokenV2CallData = function (managerAddress, liquidatorAddress, feeRecipient, rebalanceFeeCalculator, rebalanceInterval, failRebalancePeriod, lastRebalanceTimestamp, entryFee, rebalanceFeeCalculatorCalldata) {
        return rebalancing_1.generateRebalancingSetTokenV2CallData(managerAddress, liquidatorAddress, feeRecipient, rebalanceFeeCalculator, rebalanceInterval, failRebalancePeriod, lastRebalanceTimestamp, entryFee, rebalanceFeeCalculatorCalldata);
    };
    /**
     * Function for generating Buffer / calldata required for the FixedRebalanceFeeCalculator.
     *
     * @param  rebalanceFee             Rebalance fee in scaled value
     * @return                          Buffered data
     */
    SetProtocolUtils.generateFixedFeeCalculatorCalldata = function (rebalanceFee) {
        return rebalancing_1.generateFixedFeeCalculatorCalldata(rebalanceFee);
    };
    /**
     * Generates hash for price feed update
     *
     * @param   price        Price feed update
     * @param   timestamp    Timestamp for price feed update in unix time
     * @param   identifier   Salt identifying the trading pair of the price feed
     * @return  Hash of price feed update as hex string
     */
    SetProtocolUtils.hashPriceFeedHex = function (price, timestamp, identifier) {
        if (identifier === void 0) { identifier = 'ETHUSD'; }
        return oracle_1.hashPriceFeedHex(price, timestamp, identifier);
    };
    /**
     * Gets the length of a buffer's contents
     *
     * @param   buffer   A buffer of arbitray length
     * @return  Number of bytes in hex representation of the buffer
     */
    SetProtocolUtils.numBytesFromBuffer = function (buffer) {
        return encoding_1.numBytesFromBuffer(buffer);
    };
    /**
     * Gets the length of a hex string
     *
     * @param   hex   Hex string
     * @return  Number of bytes in hex representation of the hex
     */
    SetProtocolUtils.numBytesFromHex = function (hex) {
        return encoding_1.numBytesFromHex(hex);
    };
    /**
     * Generates a buffer for a primitive value padded to 32 bytes. Use for encoding addresses (string),
     * enum, etc. Use paddedBufferForBigNumber for token amounts that need to be expressed in high numbers
     *
     * @param   value   Any primitive value (string, number) to encode
     * @return  Primitive value represented as Buffer
     */
    SetProtocolUtils.paddedBufferForPrimitive = function (value) {
        return encoding_1.paddedBufferForPrimitive(value);
    };
    /**
     * Generates a buffer for a BigNumber padded to 32 bytes
     *
     * Used by various
     *
     * @param   number   BigNumber to encode
     * @return  BigNumber value represented as Buffer
     */
    SetProtocolUtils.paddedBufferForBigNumber = function (number) {
        return encoding_1.paddedBufferForBigNumber(number);
    };
    /**
     * Parses a signature and returns its elliptic curve signature
     *
     * Used by setProtocol.js in SignatureUtils
     *
     * @param   signature   Hex signature to parse
     * @return  An object containing the Elliptic curve signature parameters
     */
    SetProtocolUtils.parseSignatureHexAsRSV = function (signature) {
        return signing_1.parseSignatureHexAsRSV(signature);
    };
    /**
     * Returns the hex string representation of a string padded with '0x'
     *
     * Used by setProtocol.js in various wrappers to convert string to bytes to match transaction parameter type
     *
     * @param   input   A string primitive
     * @return  Hex of the string which can be used as a bytes32 transaction parameter
     */
    SetProtocolUtils.stringToBytes = function (input) {
        return encoding_1.stringToBytes(input);
    };
    /**
     * Determines if a liquidity source is a KyberTrade
     *
     * Used by setProtocol.js OrderAssertions
     *
     * @param   trade   A liquiduity fill source object
     * @return  Boolean for whether or not fill order is a KyberTrade
     */
    SetProtocolUtils.isKyberTrade = function (trade) {
        return typeGuards_1.isKyberTrade(trade);
    };
    /**
     * Determines if an order is a ZeroExSignedFillOrder
     *
     * Used by setProtocol.js OrderAssertions
     *
     * @param   order   A liquiduity fill source object
     * @return  Boolean for whether or not fill order is a ZeroExOrder
     */
    SetProtocolUtils.isZeroExOrder = function (order) {
        return typeGuards_1.isZeroExOrder(order);
    };
    /**
     * Encodes a ERC20 token address into a 0x ERC20 token asset data
     *
     * @param   tokenAddress   The ERC20 address to encode
     * @return  A string representing the encoded ERC20 asset details
     */
    SetProtocolUtils.encodeAddressAsAssetData = function (tokenAddress) {
        return zeroEx_1.encodeAddressAsAssetData(tokenAddress);
    };
    /**
     * Decodes the ERC20 token asset data to get the original address
     *
     * Used by setProtocol.js OrderAssertions
     *
     * @param   assetData   A string representing the encoded ERC20 asset details
     * @return  Original token address after decoding
     */
    SetProtocolUtils.extractAddressFromAssetData = function (assetData) {
        return zeroEx_1.extractAddressFromAssetData(assetData);
    };
    /* ============ Non-Static SetProtocolUtils Functions ============ */
    /**
     * Generates a byte string representing serialized exchange orders across different exchanges
     *
     * For 0x orders, it sums the fillAmounts of all 0x order and uses the total as the makerTokenAmount
     * in the exchange header that goes in front of all 0x orders
     *
     * For Kyber trades,it sums the sourceTokenAmount all each kyber trades and uses the total as the makerTokenAmount
     * in the exchange header that goes in front of all Kyber trades
     *
     * @param  orders              Array of orders from various exchanges
     * @return                     Buffer with all exchange orders formatted and concatenated
     */
    SetProtocolUtils.prototype.generateSerializedOrders = function (orders) {
        return orders_1.generateSerializedOrders(orders);
    };
    /**
     * Generates a ZeroExSignedFillOrder with signature that can be passed
     * into generateSerializedOrders to generate valid exchange orders data
     * Caller passes in the fillAmount
     *
     * @param   senderAddress           Address calling 0x Exchange contract
     * @param   makerAddress            Maker asset owner
     * @param   takerAddress            Taker assert owner
     * @param   makerFee                Fee accrused to maker
     * @param   takerFee                Fee accrued to taker
     * @param   makerAssetAmount        Amount of asset to exchange
     * @param   takerAssetAmount        Amount of asset to exchange for
     * @param   makerTokenAddress       Address of asset to exchange
     * @param   takerTokenAddress       Address of asset to exchange for
     * @param   salt                    Pseudo-random number acting as a salt
     * @param   exchangeAddress         0x Exchange contract address
     * @param   feeRecipientAddress     Address to send fee
     * @param   expirationTimeSeconds   Order expiration in unix timestamp
     * @param   fillAmount              The amount of the 0x order to fill
     * @return  Object conforming to ZeroExSignedFillOrder inteface
     */
    SetProtocolUtils.prototype.generateZeroExSignedFillOrder = function (senderAddress, makerAddress, takerAddress, makerFee, takerFee, makerAssetAmount, takerAssetAmount, makerTokenAddress, takerTokenAddress, salt, exchangeAddress, feeRecipientAddress, expirationTimeSeconds, fillAmount) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, zeroEx_1.generateZeroExSignedFillOrder(senderAddress, makerAddress, takerAddress, makerFee, takerFee, makerAssetAmount, takerAssetAmount, makerTokenAddress, takerTokenAddress, salt, exchangeAddress, feeRecipientAddress, expirationTimeSeconds, fillAmount, this.web3)];
            });
        });
    };
    /**
     * Signs a message and returns it's elliptic curve signature
     *
     * @param   message   Data to sign
     * @param   address   Address to sign with
     * @return  An object containing the Elliptic curve signature parameters
     */
    SetProtocolUtils.prototype.signMessage = function (message, address, addPrefix) {
        if (addPrefix === void 0) { addPrefix = false; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, signing_1.signMessage(this.web3, message, address, addPrefix)];
            });
        });
    };
    /**
     * Convert an EC Signature into hex format
     *
     * @param   ecSig   EC Signature object
     * @return  Hex string representation of an ECDSA signature
     */
    SetProtocolUtils.prototype.convertSigToHex = function (ecSig) {
        return signing_1.convertSigToHex(ecSig);
    };
    /**
     * Adds correct signature '0x' and signs 0x order
     *
     * @param   order   Object conforming to 0x's Order inteface
     * @return  Hex string representation of 0x 0rder signature
     */
    SetProtocolUtils.prototype.signZeroExOrderAsync = function (order) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, zeroEx_1.signZeroExOrderAsync(order, this.web3)];
            });
        });
    };
    /**
     * Exposing commonly used non-mapping constants. Mapppings are defined separately,
     * see EXCHANGES and REBALANCING_STATE for examples. Constants that only apply to
     * development environments are defined as part of SetProtocolTestUtils
     */
    SetProtocolUtils.CONSTANTS = constants_1.constants;
    /**
     * Enumeration of accepted exchange wrapper ids used as part of Exchange headers
     * { ZERO_EX: 1, KYBER: 2, TAKER_WALLET: 3 }
     */
    SetProtocolUtils.EXCHANGES = constants_1.constants.EXCHANGES;
    /**
     * Enumeration of states of rebalancing token
     * { DEFAULT: 0, PROPOSAL: 1, REBALANCE: 2 }
     */
    SetProtocolUtils.REBALANCING_STATE = constants_1.constants.REBALANCING_STATE;
    return SetProtocolUtils;
}());
exports.SetProtocolUtils = SetProtocolUtils;
/**
 * The TestUtils class is an entry-point into the set-protocols-util.js library for reusable utility
 * methods that pertain to testing
 */
var SetProtocolTestUtils = /** @class */ (function () {
    /**
     * Initialize a TestUtils class
     * @param web3   Web3 instance to use
     */
    function SetProtocolTestUtils(web3) {
        this.web3 = web3 || new web3_1.default();
    }
    /* ============ Static SetProtocolTestUtils Functions ============ */
    /**
     * Asserts that an array of logs is a subject of all of another set of logs, usually
     * all the logs of a particular transaction
     *
     * @param   actual     Formatted logs retrieved via the txHash. See getLogsFromTxHash
     * @param   expected   A manually generated array of logs for a particular transaction
     */
    SetProtocolTestUtils.assertLogEquivalence = function (actual, expected) {
        logs_1.assertLogEquivalence(actual, expected);
    };
    /* ============ Non-Static SetProtocolTestUtils Functions ============ */
    /**
     * Converts an array of Buffers into Hex
     *
     * @param   bufferArray   Array of buffers
     * @return  Hex of array of buffers represented as Bytes (string)
     */
    SetProtocolTestUtils.bufferArrayToHex = function (bufferArray) {
        return encoding_1.bufferArrayToHex(bufferArray);
    };
    /**
     * Converts an array of Bytes (each prefixed 0x) into one byte array
     *
     * @param   bytes   Array of byte strings
     * @return  A single byte string representing the array of bytes
     */
    SetProtocolTestUtils.concatBytes = function (bytes) {
        return encoding_1.concatBytes(bytes);
    };
    /**
     * Generates an exchange order header represented as a buffer array.
     *
     * @param  exchangeId            Enum corresponding to exchange id, see constants.EXCHANGES
     * @param  orderCount            Number of exchange orders
     * @param  makerTokenAmount      Amount of tokens the maker is willing to pay
     * @param  totalOrderBodyLength  Length of order data buffer
     * @return                       Array containing all inputs as buffers
     */
    SetProtocolTestUtils.generateExchangeOrderHeader = function (exchangeName, orderCount, totalOrderBodyLength) {
        return orders_1.generateExchangeOrderHeader(exchangeName, orderCount, totalOrderBodyLength);
    };
    /**
     * Generates expiration timestamp that can be used as part of IssuanceOrder
     *
     * @param   minutes   Number of minutes from now
     * @return  Expiration timestamp represented as BigNumber
     */
    SetProtocolTestUtils.generateTimestamp = function (minutes) {
        return orders_1.generateTimestamp(minutes);
    };
    /**
     * Generates a byte array with a valid 0x order that can be passed into ZeroExExchangeWrapper
     *
     * @param   order       Object conforming to 0x's Order inteface
     * @param   signature   Elliptic curve signature as hex string
     * @param   fillAmount  Amount of 0x order to fill
     * @return  Hex string representation of valid 0xExchangeWrapper order
     */
    SetProtocolTestUtils.generateZeroExExchangeWrapperOrder = function (order, signature, fillAmount) {
        return zeroEx_1.generateZeroExExchangeWrapperOrder(order, signature, fillAmount);
    };
    /**
     * Generates a 0x order. Use if exclusively generating the 0x order body. If generating
     * IssuanceOrder zeroExExchange Order interfaces, use generateZeroExSignedFillOrder
     *
     * @param   senderAddress           Address calling 0x Exchange contract
     * @param   makerAddress            Maker asset owner
     * @param   takerAddress            Taker assert owner
     * @param   makerFee                Fee accrused to maker
     * @param   takerFee                Fee accrued to taker
     * @param   makerAssetAmount        Amount of asset to exchange
     * @param   takerAssetAmount        Amount of asset to exchange for
     * @param   makerTokenAddress       Address of asset to exchange
     * @param   takerTokenAddress       Address of asset to exchange for
     * @param   salt                    Pseudo-random number acting as a salt
     * @param   exchangeAddress         0x Exchange contract address
     * @param   feeRecipientAddress     Address to send fee
     * @param   expirationTimeSeconds   Order expiration in unix timestamp
     * @return  Object conforming to 0x's Order inteface
     */
    SetProtocolTestUtils.generateZeroExOrder = function (senderAddress, makerAddress, takerAddress, makerFee, takerFee, makerAssetAmount, takerAssetAmount, makerTokenAddress, takerTokenAddress, salt, exchangeAddress, feeRecipientAddress, expirationTimeSeconds) {
        return zeroEx_1.generateZeroExOrder(senderAddress, makerAddress, takerAddress, makerFee, takerFee, makerAssetAmount, takerAssetAmount, makerTokenAddress, takerTokenAddress, salt, exchangeAddress, feeRecipientAddress, expirationTimeSeconds);
    };
    /**
     * Generates a hex string representing a single Kyber trade without the exchange header. Used for testing
     * KyberNetworkWrapper directly. For issuance order testing flows, use generateSerializedOrders which
     * includes the exchange header that core uses for dispatching the buffer to the correct wrapper
     *
     * @param  trade         An object conforming to KyberTrade to transform into buffer
     * @return               Hex string for single Kyber trade
     */
    SetProtocolTestUtils.kyberTradeToBytes = function (trade) {
        return kyber_1.kyberTradesToBytes(trade);
    };
    /**
     * Converts a 0x order into binary representation, often to get byte count
     *
     * @param   order   Object conforming to 0x's Order inteface
     * @return  Array of buffers representing the order
     */
    SetProtocolTestUtils.zeroExOrderToBuffer = function (order) {
        return zeroEx_1.zeroExOrderToBuffer(order);
    };
    /**
     * Generates a buffer with a valid 0x order that can be passed into ZeroExExchangeWrapper. Used to generate the
     * orders data separately from the header to test invalid values.
     *
     * @param   orders       ZeroExSignedFillOrder objects
     * @return  Buffer representation of valid 0xExchangeWrapper order
     */
    SetProtocolTestUtils.zeroExSignedFillOrderToBuffer = function (order) {
        return zeroEx_1.zeroExSignedFillOrderToBuffer(order, order.signature, order.fillAmount);
    };
    /**
     * Retrieves readable logs from a transaction hash
     *
     * @param   txHash   Transaction hash to retrieve logs from
     * @return  Array of logs presented as Log
     */
    SetProtocolTestUtils.prototype.getLogsFromTxHash = function (txHash) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, logs_1.getLogsFromTxHash(this.web3, txHash)];
            });
        });
    };
    /* ============ SetProtocolTestUtils Constants  ============ */
    /**
     * Address of deployed KyberNetworkProxy contract on test rpc, loaded from snapshot
     */
    SetProtocolTestUtils.KYBER_NETWORK_PROXY_ADDRESS = constants_1.constants.KYBER_NETWORK_PROXY_ADDRESS;
    /**
     * Address of deployed token to use in Kyber swap on test rpc, loaded from snapshot on account[3]
     */
    SetProtocolTestUtils.KYBER_RESERVE_SOURCE_TOKEN_ADDRESS = constants_1.constants.KYBER_RESERVE_SOURCE_TOKEN_ADDRESS;
    /**
     * Address of deployed token to receive in Kyber swap on test rpc, loaded from snapshot
     */
    SetProtocolTestUtils.KYBER_RESERVE_DESTINATION_TOKEN_ADDRESS = constants_1.constants.KYBER_RESERVE_DESTINATION_TOKEN_ADDRESS;
    /**
     * Address of deployed 0x exchange address contract on test rpc, loaded from snapshot
     */
    SetProtocolTestUtils.ZERO_EX_EXCHANGE_ADDRESS = constants_1.constants.ZERO_EX_SNAPSHOT_EXCHANGE_ADDRESS;
    /**
     * Address of deployed 0x erc20 proxy contract on test rpc, loaded from snapshot
     */
    SetProtocolTestUtils.ZERO_EX_ERC20_PROXY_ADDRESS = constants_1.constants.ZERO_EX_SNAPSHOT_ERC20_PROXY_ADDRESS;
    /**
     * Address of deployed 0x token on test rpc, loaded from snapshot
     */
    SetProtocolTestUtils.ZERO_EX_TOKEN_ADDRESS = constants_1.constants.ZERO_EX_TOKEN_ADDRESS;
    return SetProtocolTestUtils;
}());
exports.SetProtocolTestUtils = SetProtocolTestUtils;
//# sourceMappingURL=index.js.map