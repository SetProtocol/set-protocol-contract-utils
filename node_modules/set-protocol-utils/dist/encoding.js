"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var _ = __importStar(require("lodash"));
var ethUtil = __importStar(require("ethereumjs-util"));
var web3_1 = __importDefault(require("web3"));
var bignumber_1 = require("./bignumber");
var web3 = new web3_1.default();
function concatBytes(inputs) {
    if (inputs.length === 0) {
        throw new Error('No errors in concat Orders');
    }
    var bytes = '';
    _.each(inputs, function (input) {
        bytes = bytes.concat(removeHexPrefix(input));
    });
    return addHexPrefix(bytes);
}
exports.concatBytes = concatBytes;
function bufferArrayToHex(bufferArray) {
    var buffer = Buffer.concat(bufferArray);
    return ethUtil.bufferToHex(buffer);
}
exports.bufferArrayToHex = bufferArrayToHex;
function hashObject(types, values) {
    return ethUtil.sha3(solidityPack(types, values));
}
exports.hashObject = hashObject;
function hashString(value) {
    return ethUtil.sha3(value);
}
exports.hashString = hashString;
function numBytesFromBuffer(buffer) {
    var hex = bufferArrayToHex(buffer);
    return numBytesFromHex(hex);
}
exports.numBytesFromBuffer = numBytesFromBuffer;
function numBytesFromHex(hex) {
    if (!isHexPrefixed(hex)) {
        throw new Error(hex + " is not a hex string. It must be Hex-Prefixed");
    }
    return new bignumber_1.BigNumber(removeHexPrefix(hex).length).div(2);
}
exports.numBytesFromHex = numBytesFromHex;
function paddedBufferForPrimitive(input) {
    return ethUtil.setLengthLeft(ethUtil.toBuffer(input), 32);
}
exports.paddedBufferForPrimitive = paddedBufferForPrimitive;
function paddedBufferForBigNumber(number) {
    return paddedBufferForPrimitive(web3.utils.toHex(number));
}
exports.paddedBufferForBigNumber = paddedBufferForBigNumber;
function paddedBufferForBN(number) {
    return paddedBufferForPrimitive(web3.utils.toHex(number));
}
exports.paddedBufferForBN = paddedBufferForBN;
function stringToBytes(input) {
    // Padding 66 to include the '0x' prefix
    return web3.utils.fromAscii(input).padEnd(66, '0');
}
exports.stringToBytes = stringToBytes;
function elementaryName(name) {
    if (name.startsWith('int[')) {
        return 'int256' + name.slice(3);
    }
    else if (name === 'int') {
        return 'int256';
    }
    else if (name.startsWith('uint[')) {
        return 'uint256' + name.slice(4);
    }
    else if (name === 'uint') {
        return 'uint256';
    }
    return name;
}
function isHexPrefixed(str) {
    if (typeof str !== 'string') {
        throw new Error("Must be type 'string', is currently type " + (typeof str) + ', while checking isHexPrefixed.');
    }
    return str.slice(0, 2) === '0x';
}
// Parse N from type<N>
function parseTypeN(type) {
    // Figure out how to mirror parseInt in typescript
    return parseInt(/^\D+(\d+)$/.exec(type)[1], 10);
}
function parseNumber(arg) {
    var type = typeof arg;
    if (type === 'number') {
        return new bignumber_1.BigNumber(arg);
    }
    else if (type === 'object') {
        // Assume this is a BigNumber for the moment, replace with BN.isBN soon
        return arg;
    }
    else {
        throw new Error('Argument is not a supported type');
    }
}
function removeHexPrefix(input) {
    if (typeof input !== 'string') {
        return input;
    }
    return isHexPrefixed(input) ? input.slice(2) : input;
}
function addHexPrefix(input) {
    if (typeof input !== 'string') {
        return input;
    }
    return !isHexPrefixed(input) ? "0x" + input : input;
}
function solidityPack(types, values) {
    if (types.length !== values.length) {
        throw new Error('Number of types are not matching the values');
    }
    var size;
    var num;
    var ret = [];
    var j;
    for (var i = 0; i < types.length; i++) {
        var type = elementaryName(types[i]);
        var value = values[i];
        if (type === 'bytes') {
            ret.push(value);
        }
        else if (Array.isArray(values[i])) {
            var typeArray = type.split('[')[0];
            if (typeArray == 'address') {
                for (j = 0; j < value.length; j++) {
                    ret.push(ethUtil.setLengthLeft(value[j], 32));
                }
            }
            else if (typeArray == 'bool') {
                for (j = 0; j < value.length; j++) {
                    ret.push(ethUtil.setLengthLeft(new Buffer(value[j] ? 1 : 0), 32));
                }
            }
            else if (typeArray.startsWith('bytes') && (parseTypeN(typeArray) >= 1 || parseTypeN(typeArray) <= 32)) {
                for (j = 0; j < value.length; j++) {
                    ret.push(ethUtil.setLengthRight(value[j], 32));
                }
            }
            else if (typeArray.startsWith('uint')) {
                size = parseTypeN(typeArray);
                if ((size % 8) || (size < 8) || (size > 256)) {
                    throw new Error('Invalid uint<N> width: ' + size);
                }
                for (j = 0; j < value.length; j++) {
                    num = parseNumber(!value[j] ? 0 : value[j]);
                    ret.push(paddedBufferForBigNumber(num));
                }
            }
            else {
                throw new Error('Unsupported or invalid type array: ' + typeArray);
            }
        }
        else if (type === 'string') {
            ret.push(new Buffer(value, 'utf8'));
        }
        else if (type === 'bool') {
            ret.push(new Buffer(value ? '01' : '00', 'hex'));
        }
        else if (type === 'address') {
            ret.push(ethUtil.setLengthLeft(value, 20));
        }
        else if (type.startsWith('bytes')) {
            size = parseTypeN(type);
            if (size < 1 || size > 32) {
                throw new Error('Invalid bytes<N> width: ' + size);
            }
            ret.push(ethUtil.setLengthRight(value, size));
        }
        else if (type.startsWith('uint')) {
            size = parseTypeN(type);
            if ((size % 8) || (size < 8) || (size > 256)) {
                throw new Error('Invalid uint<N> width: ' + size);
            }
            num = parseNumber(value);
            ret.push(paddedBufferForBigNumber(num));
        }
        else if (type.startsWith('int')) {
            size = parseTypeN(type);
            if ((size % 8) || (size < 8) || (size > 256)) {
                throw new Error('Invalid int<N> width: ' + size);
            }
            num = parseNumber(value);
            ret.push(paddedBufferForBigNumber(num));
        }
        else {
            // FIXME: support all other types
            throw new Error('Unsupported or invalid type: ' + type);
        }
    }
    return Buffer.concat(ret);
}
//# sourceMappingURL=encoding.js.map