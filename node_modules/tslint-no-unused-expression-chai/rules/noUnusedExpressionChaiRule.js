"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var tsutils = require("tsutils");
var noUnusedExpressionRule_1 = require("tslint/lib/rules/noUnusedExpressionRule");
/**
 * Predicate to determine given failure is chai's `expect` assertion.
 * It relies on naive assumptions based on chai assertion syntax.
 */
var chaiAssertionPredicate = function (failure, source) {
    var failurePosition = failure.getStartPosition();
    var token = tsutils.getTokenAtPosition(source, failurePosition.getPosition());
    //for any reason locating token is not available, falls back to default rule
    if (!token) {
        return true;
    }
    //check very exact token is identifier, `expect`
    var isTokenIdentifier = tsutils.isIdentifier(token);
    if (!isTokenIdentifier) {
        return true;
    }
    var parentToken = token.parent;
    //same as token. located chai assertion should have parent token
    if (!parentToken) {
        return true;
    }
    //traverse up one parent, check it's call expression
    var isParentTokenCallExpression = tsutils.isCallExpression(parentToken);
    if (!isParentTokenCallExpression) {
        return true;
    }
    //finally compare actual token text to chai assertion, return false if given token is `expect`
    return token.getText() !== 'expect';
};
/**
 * Implements no-unused-expression-chai rules
 * To honor base rule's behavior, it inherits from default no-unused-expression rule
 * and override specific failure only
 *
 */
var Rule = /** @class */ (function (_super) {
    __extends(Rule, _super);
    function Rule() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Apply rules. Simply walk source by default rule first, and filter out chai expression
     *
     */
    Rule.prototype.apply = function (sourceFile) {
        var failures = _super.prototype.apply.call(this, sourceFile);
        if (failures && failures.length > 0) {
            return failures.filter(function (x) { return chaiAssertionPredicate(x, sourceFile); });
        }
        return failures;
    };
    return Rule;
}(noUnusedExpressionRule_1.Rule));
exports.Rule = Rule;
//# sourceMappingURL=noUnusedExpressionChaiRule.js.map